import json
import re
import toml
from typing import List, Dict, Optional

class Dependency:
    def __init__(self, name: str, version: str, ecosystem: str):
        self.name = name
        self.version = version
        self.ecosystem = ecosystem

    def __repr__(self):
        return f"{self.ecosystem}::{self.name}@{self.version}"

class DependencyParser:

    @staticmethod
    def parse_file(content: str, filename: str) -> List[Dependency]:
        if filename.endswith("package-lock.json"):
            return DependencyParser.parse_npm(content)
        elif filename.endswith("requirements.txt"):
            return DependencyParser.parse_pip(content)
        elif filename.endswith("Cargo.lock"):
            return DependencyParser.parse_cargo(content)
        elif filename.endswith("go.mod"):
            return DependencyParser.parse_go(content)
        else:
            raise ValueError(f"Unsupported file type: {filename}")

    @staticmethod
    def parse_npm(content: str) -> List[Dependency]:
        dependencies = []
        try:
            data = json.loads(content)

            # Prefer 'packages' (lockfile v2/v3)
            if "packages" in data:
                for path, info in data["packages"].items():
                    # Skip root package (empty string key)
                    if path == "":
                        continue

                    # Extract package name from path 'node_modules/pkgname'
                    # Handle scoped packages 'node_modules/@scope/pkgname'
                    parts = path.split("node_modules/")
                    if len(parts) > 1:
                        name = parts[-1]
                        version = info.get("version")
                        if name and version:
                            dependencies.append(Dependency(name, version, "npm"))

            # Fallback to 'dependencies' (lockfile v1) or if packages missing
            elif "dependencies" in data:
                def extract_deps(deps):
                    for name, info in deps.items():
                        version = info.get("version")
                        if version:
                            dependencies.append(Dependency(name, version, "npm"))
                        if "dependencies" in info:
                            extract_deps(info["dependencies"])

                extract_deps(data["dependencies"])

        except json.JSONDecodeError:
            pass

        return dependencies

    @staticmethod
    def parse_pip(content: str) -> List[Dependency]:
        dependencies = []
        for line in content.splitlines():
            line = line.strip()
            # Ignore comments and empty lines
            if not line or line.startswith("#"):
                continue

            # Handle inline comments
            line = line.split("#")[0].strip()

            # Regex for package constraint: name==version
            # Also handles name>=version, but stores it. Ideally strictly pinned for vulnerability check.
            # We'll extract the version if it has ==, otherwise we might just take the first specifier or ignore.
            # Let's focus on pinned versions '=='
            match = re.match(r"^([a-zA-Z0-9_\-\.]+)\s*==\s*([a-zA-Z0-9_\-\.\+]+)", line)
            if match:
                name, version = match.groups()
                dependencies.append(Dependency(name, version, "pip"))
        return dependencies

    @staticmethod
    def parse_cargo(content: str) -> List[Dependency]:
        dependencies = []
        try:
            data = toml.loads(content)
            packages = data.get("package", [])
            for pkg in packages:
                name = pkg.get("name")
                version = pkg.get("version")
                if name and version:
                    dependencies.append(Dependency(name, version, "cargo"))
        except toml.TomlDecodeError:
            pass
        return dependencies

    @staticmethod
    def parse_go(content: str) -> List[Dependency]:
        dependencies = []
        in_require = False
        for line in content.splitlines():
            line = line.strip()

            # Detect require block start
            if line.startswith("require ("):
                in_require = True
                continue
            # Detect require block end
            if line.startswith(")") and in_require:
                in_require = False
                continue

            name = None
            version = None

            if in_require:
                # inside require block
                parts = line.split()
                if len(parts) >= 2:
                    name = parts[0]
                    version = parts[1]
            elif line.startswith("require"):
                # single line require
                parts = line.split()
                if len(parts) >= 3:
                    name = parts[1]
                    version = parts[2]

            if name and version:
                # Clean up version (remove +incompatible, etc if needed, but CVEs usually match full string)
                dependencies.append(Dependency(name, version, "go"))

        return dependencies
