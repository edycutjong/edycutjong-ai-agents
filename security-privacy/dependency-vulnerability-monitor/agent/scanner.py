import requests
import logging
from typing import List, Dict, Optional
from agent.parsers import Dependency
from config import Config

class Vulnerability:
    def __init__(self, cve_id: str, summary: str, severity: str, fixed_version: str, description: str = ""):
        self.cve_id = cve_id
        self.summary = summary
        self.severity = severity
        self.fixed_version = fixed_version
        self.description = description

    def __repr__(self):
        return f"[{self.severity}] {self.cve_id}: {self.summary}"

class VulnerabilityScanner:

    def __init__(self):
        self.use_mock = Config.USE_MOCK_DATA
        self.osv_url = "https://api.osv.dev/v1/query"

    def scan(self, dependencies: List[Dependency]) -> Dict[Dependency, List[Vulnerability]]:
        results = {}
        for dep in dependencies:
            vulns = self.check_vulnerability(dep)
            if vulns:
                results[dep] = vulns
        return results

    def check_vulnerability(self, dep: Dependency) -> List[Vulnerability]:
        if self.use_mock:
            return self._mock_scan(dep)
        else:
            return self._osv_scan(dep)

    def _mock_scan(self, dep: Dependency) -> List[Vulnerability]:
        # Mock logic for demo
        vulns = []

        # Requests Mock
        if dep.name == "requests" and dep.ecosystem == "pip":
             # Simple string comparison for demo. In real app, use packaging.version
             if dep.version < "2.31.0":
                 vulns.append(Vulnerability(
                     cve_id="CVE-2023-32681",
                     summary="Requests unintended leak of Proxy-Authorization header",
                     severity="HIGH",
                     fixed_version="2.31.0",
                     description="Requests before 2.31.0 allows unintended leak of Proxy-Authorization header."
                 ))

        # Log4j Mock
        if dep.name == "log4j" or dep.name == "log4js":
            vulns.append(Vulnerability(
                cve_id="CVE-2021-44228",
                summary="Log4Shell RCE",
                severity="CRITICAL",
                fixed_version="2.15.0",
                description="Remote Code Execution in Log4j."
            ))

        # React Mock
        if dep.name == "react" and dep.ecosystem == "npm":
            if dep.version < "18.0.0":
                 vulns.append(Vulnerability(
                    cve_id="CVE-2022-1234", # Fake CVE
                    summary="Potential XSS in React",
                    severity="MEDIUM",
                    fixed_version="18.0.0",
                    description="Cross-site scripting vulnerability."
                ))

        return vulns

    def _osv_scan(self, dep: Dependency) -> List[Vulnerability]:
        # Map ecosystem names to OSV ecosystem names
        ecosystem_map = {
            "npm": "npm",
            "pip": "PyPI",
            "cargo": "Crates.io",
            "go": "Go"
        }

        ecosystem = ecosystem_map.get(dep.ecosystem)
        if not ecosystem:
            return []

        payload = {
            "package": {
                "name": dep.name,
                "ecosystem": ecosystem
            },
            "version": dep.version
        }

        try:
            response = requests.post(self.osv_url, json=payload)
            if response.status_code == 200:
                data = response.json()
                return self._parse_osv_response(data)
            else:
                logging.warning(f"OSV API returned {response.status_code} for {dep.name}")
        except Exception as e:
            logging.error(f"Error scanning {dep.name}: {e}")

        return []

    def _parse_osv_response(self, data: Dict) -> List[Vulnerability]:
        vulns = []
        if "vulns" in data:
            for v in data["vulns"]:
                cve_id = v.get("id", "UNKNOWN")
                # Prefer aliases (CVE) if available
                if "aliases" in v:
                    for alias in v["aliases"]:
                        if alias.startswith("CVE-"):
                            cve_id = alias
                            break

                summary = v.get("summary", "No summary")
                details = v.get("details", "")

                # Extract severity (CVSS) if available
                severity = "UNKNOWN"
                if "severity" in v:
                    for s in v["severity"]:
                        if s["type"] == "CVSS_V3":
                            # Just storing the score string for now
                            severity = s["score"]
                            # We could parse it to HIGH/MEDIUM/LOW

                # Find fixed version
                fixed_version = "UNKNOWN"
                if "affected" in v:
                    for affected in v["affected"]:
                        if "ranges" in affected:
                            for r in affected["ranges"]:
                                if "events" in r:
                                    for event in r["events"]:
                                        if "fixed" in event:
                                            fixed_version = event["fixed"]
                                            # Keep looking for latest fixed version or break?
                                            # Usually vulnerabilities list the fix for the affected range.
                                            break

                vulns.append(Vulnerability(
                    cve_id=cve_id,
                    summary=summary,
                    severity=severity,
                    fixed_version=fixed_version,
                    description=details
                ))
        return vulns
