import os
import sys
import argparse
from typing import List, Dict, Any

# Ensure we can import tools
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from tools.audit import run_npm_audit, extract_vulnerabilities
from tools.patcher import get_installed_version, update_package, update_lockfile
from tools.tester import run_tests
from tools.git_utils import create_branch, commit_changes, push_changes, create_pr, get_repo
from tools.notifier import notify_team

from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table
from rich.panel import Panel

# Optional: LangChain for PR description
try:
    from langchain.llms import OpenAI
    from langchain.prompts import PromptTemplate
    HAS_LANGCHAIN = True
except ImportError:
    HAS_LANGCHAIN = False

console = Console()

def generate_pr_description(pkg_name: str, vulns: List[Dict[str, Any]], old_version: str, new_version: str) -> str:
    """Generates a PR description using OpenAI if available, otherwise a template."""
    vuln_summary = "\n".join([f"- {v['severity'].upper()}: {v.get('title', 'Vulnerability')}" for v in vulns])

    if HAS_LANGCHAIN and os.getenv("OPENAI_API_KEY"):
        try:
            llm = OpenAI(temperature=0.7)
            prompt = PromptTemplate(
                input_variables=["package", "old_version", "new_version", "vuln_summary"],
                template="""
                Write a professional GitHub Pull Request description for a security patch.

                Package: {package}
                Update: {old_version} -> {new_version}
                Vulnerabilities Fixed:
                {vuln_summary}

                The PR should explain why this update is necessary and what it fixes.
                """
            )
            return llm.invoke(prompt.format(
                package=pkg_name,
                old_version=old_version,
                new_version=new_version,
                vuln_summary=vuln_summary
            ))
        except Exception as e:
            console.print(f"[yellow]Warning: Failed to generate PR description with AI: {e}[/yellow]")

    return f"""
    # Security Patch: {pkg_name}

    Updates `{pkg_name}` from {old_version} to {new_version} to fix security vulnerabilities.

    ## Vulnerabilities Fixed
    {vuln_summary}

    Auto-generated by VulnAutoPatcher.
    """

def main():
    parser = argparse.ArgumentParser(description="VulnAutoPatcher: Automated security patching agent.")
    parser.add_argument("--path", type=str, default=".", help="Path to the project to patch")
    parser.add_argument("--dry-run", action="store_true", help="Do not push or create PRs")
    parser.add_argument("--base-branch", type=str, default="main", help="Base branch to branch off from")
    args = parser.parse_args()

    project_path = args.path
    base_branch = args.base_branch

    console.print(Panel.fit("üõ°Ô∏è  VulnAutoPatcher Started", style="bold blue"))

    # Check for dirty state
    try:
        repo = get_repo(project_path)
        if repo.is_dirty() or repo.untracked_files:
            console.print("[red]Repo is dirty. Please commit or stash changes before running.[/red]")
            return
    except Exception as e:
        console.print(f"[red]Error initializing git repo: {e}[/red]")
        return

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console
    ) as progress:

        # Step 1: Audit
        task1 = progress.add_task("[cyan]Running npm audit...", total=None)
        audit_report = run_npm_audit(project_path)
        progress.update(task1, completed=True)

        if "error" in audit_report:
             console.print(f"[red]Error running audit: {audit_report['error']}[/red]")
             return

        vulnerabilities = extract_vulnerabilities(audit_report)
        console.print(f"[green]Found {len(vulnerabilities)} vulnerabilities.[/green]")

        if not vulnerabilities:
            return

        # Group vulnerabilities by package
        vulns_by_pkg = {}
        for vuln in vulnerabilities:
            pkg = vuln["package"]
            if pkg not in vulns_by_pkg:
                vulns_by_pkg[pkg] = []
            vulns_by_pkg[pkg].append(vuln)

        # Display Vulnerabilities
        table = Table(title="Vulnerabilities Found")
        table.add_column("Package", style="cyan")
        table.add_column("Severity", style="magenta")
        table.add_column("Current Version", style="yellow")
        table.add_column("Fix Info", style="green")

        for pkg, vulns in vulns_by_pkg.items():
            current_ver = get_installed_version(pkg, project_path)
            # Store current version in vulns
            for v in vulns:
                v["current_version"] = current_ver

            max_severity = max([v["severity"] for v in vulns], key=lambda x: ["low", "moderate", "high", "critical"].index(x) if x in ["low", "moderate", "high", "critical"] else 0)

            # Use fix info from first vuln (usually consistent per package)
            fix_info = "Available" if any(v["fix_available"] for v in vulns) else "None"
            if any(v.get("fix_version") for v in vulns):
                fix_info = next(v["fix_version"] for v in vulns if v.get("fix_version"))

            table.add_row(
                pkg,
                max_severity,
                current_ver or "Unknown",
                fix_info
            )

        console.print(table)

        # Step 2: Patch Loop
        for pkg, vulns in vulns_by_pkg.items():
            # Check if any have fix available
            if not any(v["fix_available"] for v in vulns):
                console.print(f"[yellow]Skipping {pkg}: No fix available.[/yellow]")
                continue

            current_ver = vulns[0].get("current_version")
            if not current_ver:
                 console.print(f"[yellow]Skipping {pkg}: Could not determine current version.[/yellow]")
                 continue

            console.print(f"\n[bold]Attempting to patch {pkg}...[/bold]")

            # Ensure we are on base branch
            try:
                console.print(f"Checking out {base_branch}...")
                repo.heads[base_branch].checkout()
                # We assume local base is up to date or user handled it.
                # Attempt to pull? Maybe risky if conflicts.
            except Exception as e:
                console.print(f"[red]Failed to checkout {base_branch}: {e}[/red]")
                continue

            # Create Branch
            branch_name = f"fix/{pkg}-security-update"
            if not create_branch(branch_name, project_path):
                console.print(f"[red]Failed to create branch {branch_name}.[/red]")
                continue

            # Determine Target Version
            target_version = "latest"
            # Prefer explicit fix version if available
            fix_ver = next((v.get("fix_version") for v in vulns if v.get("fix_version")), None)
            if fix_ver:
                target_version = fix_ver

            task_patch = progress.add_task(f"[cyan]Updating {pkg} to {target_version}...", total=None)
            success = update_package(pkg, target_version, project_path)
            progress.update(task_patch, completed=True)

            if not success:
                console.print(f"[red]Failed to update {pkg}.[/red]")
                # Revert changes
                repo.git.checkout(".")
                # Switch back to base
                repo.heads[base_branch].checkout()
                continue

            # Update Lockfile
            update_lockfile(project_path)

            # Run Tests
            task_test = progress.add_task(f"[cyan]Running tests for {pkg}...", total=None)
            test_result = run_tests(project_path)
            progress.update(task_test, completed=True)

            if test_result["success"]:
                console.print(f"[green]Tests passed for {pkg}![/green]")

                if not args.dry_run:
                    commit_msg = f"fix(deps): update {pkg} to fix security vulnerability"
                    if commit_changes(commit_msg, project_path):
                        console.print(f"[green]Changes committed.[/green]")

                        push_changes(branch_name, "origin", project_path)
                        console.print(f"[green]Branch pushed.[/green]")

                        # Get new version (actual installed)
                        new_ver = get_installed_version(pkg, project_path) or target_version

                        pr_body = generate_pr_description(pkg, vulns, current_ver, new_ver)
                        pr_url = create_pr(
                            title=commit_msg,
                            body=pr_body,
                            head_branch=branch_name,
                            base_branch=base_branch,
                            repo_path=project_path
                        )

                        if pr_url:
                            notify_team(f"PR Created for {pkg}: {pr_url}", level="success")
                        else:
                            notify_team(f"Failed to create PR for {pkg}", level="error")
                    else:
                         console.print("[yellow]No changes to commit.[/yellow]")
                else:
                    console.print("[blue]Dry run: Skipping commit/push/PR.[/blue]")

                # Cleanup: checkout base for next package
                # (Ideally delete local branch too to keep clean)
                repo.heads[base_branch].checkout()

            else:
                console.print(f"[red]Tests failed for {pkg}.[/red]")
                notify_team(f"Auto-patch failed for {pkg}. Manual intervention required.", level="error")

                # Revert changes
                repo.git.checkout(".")
                # Checkout base
                repo.heads[base_branch].checkout()

if __name__ == "__main__":
    main()
